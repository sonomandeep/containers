---
import Card from "../ui/Card.astro";

type LogTone = "info" | "warn" | "error";

type LogRow = {
  tone: LogTone;
  service: string;
  message: string;
};

type Props = {
  class?: string;
};

const { class: className = "" } = Astro.props as Props;
const cardClass = `h-80 justify-end ${className}`.trim();

const logRows: Array<LogRow> = [
  {
    tone: "info",
    service: "nginx",
    message: "Config reload completed from /etc/nginx/nginx.conf",
  },
  {
    tone: "info",
    service: "api",
    message: "HTTP server listening on 0.0.0.0:3000",
  },
  {
    tone: "info",
    service: "postgres",
    message: "Connection pool initialized (max=20)",
  },
  {
    tone: "info",
    service: "worker",
    message: "Job processor started (concurrency=4)",
  },
  {
    tone: "info",
    service: "redis",
    message: "AOF rewrite completed in 428ms",
  },
  {
    tone: "info",
    service: "web",
    message: "New deployment detected: paper-www@2026.02.25-2",
  },
  {
    tone: "warn",
    service: "api",
    message: "p95 latency on GET /api/products reached 842ms",
  },
  {
    tone: "info",
    service: "api",
    message: "Latency recovered on GET /api/products (p95=436ms)",
  },
  {
    tone: "warn",
    service: "redis",
    message: "Memory usage at 79%, eviction policy allkeys-lru",
  },
  {
    tone: "info",
    service: "redis",
    message: "Evicted 12 keys, memory pressure normalized",
  },
  {
    tone: "error",
    service: "nginx",
    message: "Upstream api:3000 returned 502 for GET /checkout",
  },
  {
    tone: "info",
    service: "nginx",
    message: "Upstream api:3000 recovered after 1 retry",
  },
  {
    tone: "info",
    service: "worker",
    message: "Processed job payment.capture in 184ms",
  },
  {
    tone: "warn",
    service: "worker",
    message: "Queue depth high (critical-jobs=46)",
  },
  {
    tone: "info",
    service: "worker",
    message: "Autoscaled worker replicas from 2 to 3",
  },
  {
    tone: "info",
    service: "worker",
    message: "Queue depth back to normal (critical-jobs=8)",
  },
  {
    tone: "error",
    service: "postgres",
    message: "Deadlock detected while updating order_events",
  },
  {
    tone: "info",
    service: "postgres",
    message: "Deadlock resolved after transaction retry",
  },
  {
    tone: "warn",
    service: "postgres",
    message: "Replication lag to replica-1 reached 2.1s",
  },
  {
    tone: "info",
    service: "postgres",
    message: "Replication lag recovered to 180ms",
  },
  {
    tone: "warn",
    service: "api",
    message: "Circuit breaker opened for billing-provider",
  },
  {
    tone: "info",
    service: "api",
    message: "Circuit breaker closed after successful probes",
  },
  {
    tone: "error",
    service: "worker",
    message: "Webhook dispatch to stripe failed (attempt 1/5)",
  },
  {
    tone: "info",
    service: "worker",
    message: "Webhook dispatch to stripe succeeded on retry (attempt 2/5)",
  },
  {
    tone: "info",
    service: "api",
    message: "Health check passed (uptime=13h12m)",
  },
  {
    tone: "info",
    service: "web",
    message: "Static assets cache warmed (37 files)",
  },
];

const toneClasses: Record<LogTone, string> = {
  info: "text-blue-600",
  warn: "text-amber-600",
  error: "text-red-600",
};
---

<Card as="article" class={cardClass}>
  <div
    aria-hidden="true"
    class="relative flex-1 overflow-hidden pb-8"
    data-log-stream
    data-max-rows={logRows.length}
    data-log-rows={JSON.stringify(logRows)}
  >
    <div class="space-y-2">
      <div
        class="grid grid-cols-[84px_52px_minmax(0,1fr)] gap-x-1.5 font-mono text-[10px] tracking-[0.06em] text-neutral-400 uppercase"
      >
        <span>SERVICE</span>
        <span>LEVEL</span>
        <span>MESSAGE</span>
      </div>

      <ul
        class="m-0 flex list-none flex-col gap-y-1 p-0 will-change-transform"
        data-log-stream-list
      >
        {
          logRows.map((row) => (
            <li class="grid grid-cols-[84px_52px_minmax(0,1fr)] gap-x-1.5 text-xs leading-[1.25]">
              <span class="font-mono text-neutral-500">[{row.service}]</span>
              <span class={`font-mono ${toneClasses[row.tone]}`}>
                {row.tone.toUpperCase()}
              </span>
              <span class="truncate text-neutral-700">{row.message}</span>
            </li>
          ))
        }
      </ul>
    </div>

    <div
      class="pointer-events-none absolute inset-x-0 bottom-0 h-40 bg-linear-to-b from-transparent from-45% to-neutral-50"
    />
  </div>

  <h3
    class="font-display text-base font-medium tracking-[-0.01em] text-neutral-800"
  >
    Log stream
  </h3>
  <p class="mt-1 max-w-[13.375rem] text-balance text-sm text-neutral-500">
    Follow your containers log stream from Paper interface.
  </p>
</Card>

<script is:inline>
  const LOG_INSERT_INTERVAL_MS = 1600;
  const LOG_ANIMATION_DURATION_MS = 350;
  const LOG_ANIMATION_EASING = "cubic-bezier(0.22, 1, 0.36, 1)";

  const toneClassMap = {
    info: "text-blue-600",
    warn: "text-amber-600",
    error: "text-red-600",
  };

  const reducedMotionMediaQuery = window.matchMedia(
    "(prefers-reduced-motion: reduce)"
  );

  const createLogRowElement = (row) => {
    const rowElement = document.createElement("li");
    rowElement.className =
      "grid grid-cols-[84px_52px_minmax(0,1fr)] gap-x-1.5 text-xs leading-[1.25]";

    const serviceElement = document.createElement("span");
    serviceElement.className = "font-mono text-neutral-500";
    serviceElement.textContent = `[${row.service}]`;

    const levelElement = document.createElement("span");
    levelElement.className = `font-mono ${toneClassMap[row.tone] ?? toneClassMap.info}`;
    levelElement.textContent = row.tone.toUpperCase();

    const messageElement = document.createElement("span");
    messageElement.className = "truncate text-neutral-700";
    messageElement.textContent = row.message;

    rowElement.append(serviceElement, levelElement, messageElement);

    return rowElement;
  };

  const parseRowsFromRoot = (root) => {
    const serializedRows = root.dataset.logRows;

    if (!serializedRows) {
      return [];
    }

    try {
      const parsedRows = JSON.parse(serializedRows);

      return Array.isArray(parsedRows) ? parsedRows : [];
    } catch {
      return [];
    }
  };

  const shuffleRows = (rows) => {
    const shuffledRows = [...rows];

    for (let index = shuffledRows.length - 1; index > 0; index -= 1) {
      const randomIndex = Math.floor(Math.random() * (index + 1));
      const row = shuffledRows[index];

      shuffledRows[index] = shuffledRows[randomIndex];
      shuffledRows[randomIndex] = row;
    }

    return shuffledRows;
  };

  const setupLogStreamAnimation = (root) => {
    if (root.dataset.logStreamInitialized === "true") {
      return;
    }

    root.dataset.logStreamInitialized = "true";

    const listElement = root.querySelector("[data-log-stream-list]");

    if (!(listElement instanceof HTMLUListElement)) {
      return;
    }

    const sourceRows = parseRowsFromRoot(root);

    if (sourceRows.length === 0) {
      return;
    }

    const maxRows =
      Number.parseInt(root.dataset.maxRows ?? "", 10) ||
      listElement.childElementCount;

    let rows = shuffleRows(sourceRows);
    const initialRows = rows.slice(0, maxRows);

    listElement.replaceChildren(
      ...initialRows.map((row) => createLogRowElement(row))
    );

    let intervalId = 0;
    let nextRowIndex = initialRows.length;
    let isAnimating = false;

    const stopAnimation = () => {
      if (intervalId === 0) {
        return;
      }

      window.clearInterval(intervalId);
      intervalId = 0;
    };

    const animateNextRow = () => {
      if (isAnimating || document.hidden || reducedMotionMediaQuery.matches) {
        return;
      }

      if (nextRowIndex >= rows.length) {
        rows = shuffleRows(sourceRows);
        nextRowIndex = 0;
      }

      const nextRow = rows[nextRowIndex];
      nextRowIndex += 1;

      const newRowElement = createLogRowElement(nextRow);
      listElement.prepend(newRowElement);

      const rowGap = Number.parseFloat(
        window.getComputedStyle(listElement).rowGap || "0"
      );
      const shift = newRowElement.getBoundingClientRect().height + rowGap;

      isAnimating = true;
      listElement.style.transition = "none";
      listElement.style.transform = `translateY(-${shift}px)`;
      listElement.getBoundingClientRect();
      listElement.style.transition = `transform ${LOG_ANIMATION_DURATION_MS}ms ${LOG_ANIMATION_EASING}`;
      listElement.style.transform = "translateY(0)";

      window.setTimeout(() => {
        if (listElement.childElementCount > maxRows) {
          listElement.lastElementChild?.remove();
        }

        listElement.style.transition = "";
        listElement.style.transform = "";
        isAnimating = false;
      }, LOG_ANIMATION_DURATION_MS);
    };

    const startAnimation = () => {
      if (intervalId !== 0 || reducedMotionMediaQuery.matches) {
        return;
      }

      intervalId = window.setInterval(animateNextRow, LOG_INSERT_INTERVAL_MS);
    };

    const observer = new IntersectionObserver(
      (entries) => {
        for (const entry of entries) {
          if (!entry.isIntersecting) {
            stopAnimation();
            continue;
          }

          startAnimation();
        }
      },
      { threshold: 0.35 }
    );

    observer.observe(root);

    document.addEventListener("visibilitychange", () => {
      if (document.hidden) {
        stopAnimation();
        return;
      }

      const bounds = root.getBoundingClientRect();
      const isVisible = bounds.top < window.innerHeight && bounds.bottom > 0;

      if (isVisible) {
        startAnimation();
      }
    });
  };

  for (const root of document.querySelectorAll("[data-log-stream]")) {
    if (!(root instanceof HTMLElement)) {
      continue;
    }

    setupLogStreamAnimation(root);
  }
</script>
